package tech.chhsich.backend.service;

import tech.chhsich.backend.entity.Menu;
import tech.chhsich.backend.entity.OrderInfo;
import tech.chhsich.backend.entity.OrderEntry;
import tech.chhsich.backend.mapper.MenuMapper;
import tech.chhsich.backend.mapper.OrderInfoMapper;
import tech.chhsich.backend.mapper.OrderEntryMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Service
public class OrderService {

    @Autowired
    private OrderInfoMapper orderInfoMapper;

    @Autowired
    private OrderEntryMapper orderEntryMapper;

    @Autowired
    private UserService userService;

    @Autowired
    private MenuMapper menuMapper;

    @Autowired
    private CategoryService categoryService;

    /**
     * Creates a new order for the given user and persists both the order and its entries.
     *
     * <p>The method validates that the user exists, computes the total price using each menu's
     * `price2` (hot-sale price), inserts the OrderInfo record, inserts corresponding OrderEntry
     * records, and increments each Menu's sales count (xiaoliang). The created order's status is set
     * to 0 (pending) and its creation time is set to the current time.
     *
     * @param username the username of the purchaser
     * @param items a list of OrderItemRequest describing menu items to include (each contains a
     *              menuId and a quantity)
     * @param address delivery address to store with the order
     * @param phone contact phone to store with the order
     * @return the persisted OrderInfo with generated order ID and calculated totalPrice
     * @throws RuntimeException if the user does not exist, or any referenced menu is missing or
     *                          has been taken off shelf (productLock == 1)
     */
    @Transactional
    public OrderInfo createOrder(String username, List<OrderItemRequest> items, String address, String phone) {
        // 检查用户是否存在
        if (userService.getUserByUsername(username) == null) {
            throw new RuntimeException("用户不存在");
        }

        OrderInfo order = new OrderInfo();
        order.setOrderid(generateOrderId());
        order.setUsername(username);
        order.setAddress(address);
        order.setPhone(phone);
        order.setCreateTime(LocalDateTime.now());
        order.setStatus(0); // 0-待受理

        double totalPrice = 0;

        // 计算总价并准备订单项
        for (OrderItemRequest item : items) {
            Menu menu = menuMapper.selectById(item.getMenuId());
            if (menu == null || menu.getProductLock() == 1) {
                throw new RuntimeException("商品不存在或已下架: " + item.getMenuId());
            }

            totalPrice += menu.getPrice2() * item.getQuantity();
        }

        order.setTotalPrice(totalPrice);

        // 插入订单主信息
        orderInfoMapper.insert(order);

        // 插入订单项
        for (OrderItemRequest item : items) {
            Menu menu = menuMapper.selectById(item.getMenuId());

            OrderEntry entry = new OrderEntry();
            entry.setProductId(menu.getId());
            entry.setProductName(menu.getName());
            entry.setPrice(menu.getPrice2()); // 使用热销价
            entry.setProductNum(item.getQuantity());
            entry.setOrderId(order.getOrderid());

            orderEntryMapper.insert(entry);

            // 更新销量
            menu.setXiaoliang((menu.getXiaoliang() != null ? menu.getXiaoliang() : 0) + item.getQuantity());
            menuMapper.updateById(menu);
        }

        return order;
    }

    /**
     * Retrieves all orders placed by the specified user.
     *
     * @param username the username whose orders to fetch
     * @return a list of OrderInfo for the user; empty if the user has no orders
     */
    public List<OrderInfo> getUserOrders(String username) {
        return orderInfoMapper.findByUsername(username);
    }

    /**
     * Retrieve an order by its order identifier.
     *
     * @param orderid the unique order ID (e.g. generated by {@code generateOrderId})
     * @return the OrderInfo for the given order ID, or {@code null} if no matching order exists
     */
    public OrderInfo getOrderById(String orderid) {
        return orderInfoMapper.findByOrderid(orderid);
    }

    /**
     * Retrieves all order items (OrderEntry) associated with the given order ID.
     *
     * @param orderid the order identifier
     * @return a list of OrderEntry records for the order; empty list if none are found
     */
    public List<OrderEntry> getOrderItems(String orderid) {
        return orderEntryMapper.findByOrderid(orderid);
    }

    /**
     * Cancels an order if it is currently pending (status == 0).
     *
     * Attempts to set the order's status to 2 (canceled) and persist the change.
     *
     * @param orderid the unique identifier of the order to cancel
     * @return true if the order existed and was transitioned from pending to canceled; false otherwise
     */
    @Transactional
    public boolean cancelOrder(String orderid) {
        OrderInfo order = orderInfoMapper.findByOrderid(orderid);
        if (order != null && order.getStatus() == 0) {
            order.setStatus(2); // 2-已取消
            orderInfoMapper.updateById(order);
            return true;
        }
        return false;
    }

    /**
     * Update the status of an existing order.
     *
     * Sets the order identified by `orderid` to the provided `status` value.
     *
     * @param orderid the unique order identifier
     * @param status  the new status code to set for the order
     * @return true if the order was found and updated; false if no order with the given `orderid` exists
     */
    @Transactional
    public boolean updateOrderStatus(String orderid, Integer status) {
        OrderInfo order = orderInfoMapper.findByOrderid(orderid);
        if (order != null) {
            order.setStatus(status);
            orderInfoMapper.updateById(order);
            return true;
        }
        return false;
    }

    /**
     * Generates a unique order identifier.
     *
     * The ID is prefixed with "ORD" followed by 12 uppercase hexadecimal characters.
     *
     * @return a generated order ID in the form "ORDXXXXXXXXXXXX"
     */
    private String generateOrderId() {
        return "ORD" + UUID.randomUUID().toString().replace("-", "").substring(0, 12).toUpperCase();
    }

    public static class OrderItemRequest {
        private Long menuId;
        private Integer quantity;

        /**
 * Returns the menu item ID for this request.
 *
 * @return the menu item's database ID, or null if not set
 */
        public Long getMenuId() { return menuId; }
        /**
 * Sets the menu (product) identifier for this order item.
 *
 * @param menuId the menu item's database id
 */
public void setMenuId(Long menuId) { this.menuId = menuId; }

        /**
 * Returns the quantity of the requested menu item.
 *
 * @return the number of units requested, or {@code null} if not set
 */
public Integer getQuantity() { return quantity; }
        /**
 * Sets the quantity for this order item.
 *
 * @param quantity the number of units for the item
 */
public void setQuantity(Integer quantity) { this.quantity = quantity; }
    }
}